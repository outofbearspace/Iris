[{"title":"Iris","type":0,"sectionRef":"#","url":"/Iris/docs/intro","content":"Iris Iris is an Immediate mode GUI Library for Roblox, Based on Dear ImGui. It solves the same problems as Dear ImGui. It is fast, portable, and self-contained.","keywords":""},{"title":"Plot","type":0,"sectionRef":"#","url":"/Iris/api/Plot","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Plot","url":"/Iris/api/Plot#properties","content":" "},{"title":"ProgressBar​","type":1,"pageTitle":"Plot","url":"/Iris/api/Plot#ProgressBar","content":"Widget HasState &lt;/&gt; Plot.ProgressBar: Iris.PrograssBar A progress bar line with a state value to show the current state. hasChildren = false hasState = true Arguments = { Text: string? = &quot;Progress Bar&quot;, Format: string? = nil -- optional to override with a custom progress such as `29/54` } Events = { hovered: () -&gt; boolean, changed: () -&gt; boolean } States = { progress: State&lt;number&gt;? }  "},{"title":"Events","type":0,"sectionRef":"#","url":"/Iris/docs/events","content":"Events Each widget has a number of events connected to it. You can see these events on the API page. Certain events will happen once, such as a window being collapsed or a button being clicked. Other events can be continuous, such as a widget being hovered. Each event is a function which returns a boolean value for whether the event has happened that frame or not. To listen to an event, use the following: local button = Iris.Button({ &quot;Please click me!&quot; }) if button.clicked() then print(&quot;The button was clicked!&quot;) end Events will fire the frame after the initial action happened. This is so that any changes caused by that event can propogate visually. For example on a checkbox: [Frames 1 - 60]The mouse is elsewhere. [Frames 61 - 80]The user is moving their moues towards the checkbox. [Frame 81 - 100]The mouse enters the checkbox. The .hovered() event fires because this event will fire on the frame. [Frame 101]The user presses MouseButton1 down on the checkbox. [Frame 102]The user releases the MouseButton1. [Frame 103]The checkbox tick appears. The .checked() event fires.","keywords":""},{"title":"Format","type":0,"sectionRef":"#","url":"/Iris/api/Format","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#properties","content":" "},{"title":"Separator​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#Separator","content":"Widget &lt;/&gt; Format.Separator: Iris.Separator A vertical or horizonal line, depending on the context, which visually seperates widgets. hasChildren = false hasState = false   "},{"title":"Indent​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#Indent","content":"Widget HasChildren &lt;/&gt; Format.Indent: Iris.Indent Indents its child widgets. hasChildren = true hasState = false Arguments = { Width: number? = Iris._config.IndentSpacing -- indent width ammount. }   "},{"title":"Sameline​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#Sameline","content":"Widget HasChildren &lt;/&gt; Format.Sameline: Iris.Sameline Positions its children in a row, horizontally. hasChildren = true hasState = false Arguments = { Width: number? = Iris._config.ItemSpacing.X, -- horizontal spacing between child widgets. VerticalAlignment: Enum.VerticalAlignment? = Enum.VerticalAlignment.Center -- how widgets are aligned to the widget. }   "},{"title":"Group​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#Group","content":"Widget HasChildren &lt;/&gt; Format.Group: Iris.Group Layout widget which contains its children as a single group. hasChildren = true hasState = false  "},{"title":"State","type":0,"sectionRef":"#","url":"/Iris/api/State","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"State","url":"/Iris/api/State#functions","content":" "},{"title":"get​","type":1,"pageTitle":"State","url":"/Iris/api/State#get","content":"&lt;/&gt; State:get() → any Returns the states current value.  "},{"title":"set​","type":1,"pageTitle":"State","url":"/Iris/api/State#set","content":"&lt;/&gt; State:set() → () Allows the caller to assign the state object a new value, and returns the new value.  "},{"title":"onChange​","type":1,"pageTitle":"State","url":"/Iris/api/State#onChange","content":"&lt;/&gt; State:onChange() → () Allows the caller to connect a callback which is called when the states value is changed. "},{"title":"Table","type":0,"sectionRef":"#","url":"/Iris/api/Table","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#properties","content":" "},{"title":"Table​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#Table","content":"Widget HasChildren &lt;/&gt; Table.Table: Iris.Table A layout widget which allows children to be displayed in configurable columns and rows. hasChildren = true hasState = false Arguments = { NumColumns = number, RowBg = boolean? = false, -- whether the row backgrounds alternate a background fill. BordersOuter = boolean? = false, BordersInner = boolean? = false, -- borders on each cell. } Events = { hovered: () -&gt; boolean }  "},{"title":"Functions​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#functions","content":" "},{"title":"NextColumn​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#NextColumn","content":"&lt;/&gt; Table.NextColumn() → () In a table, moves to the next available cell. if the current cell is in the last column, then the next cell will be the first column of the next row.  "},{"title":"SetColumnIndex​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#SetColumnIndex","content":"&lt;/&gt; Table.SetColumnIndex(index: number) → () In a table, directly sets the index of the column.  "},{"title":"NextRow​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#NextRow","content":"&lt;/&gt; Table.NextRow() → () In a table, moves to the next available row, skipping cells in the previous column if the last cell wasn't in the last column "},{"title":"Tree","type":0,"sectionRef":"#","url":"/Iris/api/Tree","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Tree","url":"/Iris/api/Tree#properties","content":" "},{"title":"Tree​","type":1,"pageTitle":"Tree","url":"/Iris/api/Tree#Tree","content":"Widget HasChildren HasState &lt;/&gt; Tree.Tree: Iris.Tree A collapsable container for other widgets, to organise and hide widgets when not needed. The state determines whether the child widgets are visible or not. Clicking on the widget will collapse or uncollapse it. hasChildren: true hasState: true Arguments = { Text: string, SpanAvailWidth: boolean? = false, -- the tree title will fill all horizontal space to the end its parent container. NoIndent: boolean? = false -- the child widgets will not be indented underneath. } Events = { collapsed: () -&gt; boolean, uncollapsed: () -&gt; boolean, hovered: () -&gt; boolean } State = { isUncollapsed: State&lt;boolean&gt;? -- whether the widget is collapsed. }   "},{"title":"CollapsingHeader​","type":1,"pageTitle":"Tree","url":"/Iris/api/Tree#CollapsingHeader","content":"Widget HasChildren HasState &lt;/&gt; Tree.CollapsingHeader: Iris.CollapsingHeader The same as a Tree Widget, but with a larger title and clearer, used mainly for organsing widgets on the first level of a window. hasChildren: true hasState: true Arguments = { Text: string } Events = { collapsed: () -&gt; boolean, uncollapsed: () -&gt; boolean, hovered: () -&gt; boolean } State = { isUncollapsed: State&lt;boolean&gt;? -- whether the widget is collapsed. }  "},{"title":"Basic","type":0,"sectionRef":"#","url":"/Iris/api/Basic","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#properties","content":" "},{"title":"Button​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#Button","content":"Widget &lt;/&gt; Basic.Button: Iris.Button A clickable button the size of the text with padding. Can listen to the clicked() event to determine if it was pressed. hasChildren = false hasState = false Arguments = { Text: string, } Events = { clicked: () -&gt; boolean, rightClicked: () -&gt; boolean, doubleClicked: () -&gt; boolean, ctrlClicked: () -&gt; boolean, -- when the control key is down and clicked. hovered: () -&gt; boolean }   "},{"title":"SmallButton​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#SmallButton","content":"Widget &lt;/&gt; Basic.SmallButton: Iris.SmallButton A smaller clickable button, the same as a Iris.Button but without padding. Can listen to the clicked() event to determine if it was pressed. hasChildren = false hasState = false Arguments = { Text: string, } Events = { clicked: () -&gt; boolean, rightClicked: () -&gt; boolean, doubleClicked: () -&gt; boolean, ctrlClicked: () -&gt; boolean, -- when the control key is down and clicked. hovered: () -&gt; boolean }   "},{"title":"Checkbox​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#Checkbox","content":"Widget HasState &lt;/&gt; Basic.Checkbox: Iris.Checkbox A checkable box with a visual tick to represent a boolean true or false state. hasChildren = false hasState = true Arguments = { Text: string } Events = { checked: () -&gt; boolean, -- once when checked. unchecked: () -&gt; boolean, -- once when unchecked. hovered: () -&gt; boolean } State = { isChecked = State&lt;boolean&gt;? -- whether the box is checked. }   "},{"title":"RadioButton​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#RadioButton","content":"Widget HasState &lt;/&gt; Basic.RadioButton: Iris.RadioButton A circular selectable button, changing the state to its index argument. Used in conjunction with multiple other RadioButtons sharing the same state to represent one value from multiple options. hasChildren = false hasState = true Arguments = { Text: string, Index: any -- the state object is set to when clicked. } Events = { selected: () -&gt; boolean, unselected: () -&gt; boolean, active: () -&gt; boolean, -- if the state index equals the RadioButton's index. hovered: () -&gt; boolean } State = { index = State&lt;any&gt;? -- the state set by the index of a RadioButton. }  "},{"title":"Window","type":0,"sectionRef":"#","url":"/Iris/api/Window","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Window","url":"/Iris/api/Window#properties","content":" "},{"title":"Window​","type":1,"pageTitle":"Window","url":"/Iris/api/Window#Window","content":"Widget HasChildren HasState &lt;/&gt; Window.Window: Iris.Window The top-level container for all other widgets to be created within. Can be moved and resized across the screen. Cannot contain embedded windows. Menus can be appended to windows creating a menubar. hasChildren = true hasState = true Arguments = { Title: string, NoTitleBar: boolean? = false, NoBackground: boolean? = false, -- the background behind the widget container. NoCollapse: boolean? = false, NoClose: boolean? = false, NoMove: boolean? = false, NoScrollbar: boolean? = false, -- the scrollbar if the window is too short for all widgets. NoResize: boolean? = false, NoNav: boolean? = false, -- unimplemented. NoMenu: boolean? -- whether the menubar will show if created. } Events = { opened: () -&gt; boolean, -- once when opened. closed: () -&gt; boolean, -- once when closed. collapsed: () -&gt; boolean, -- once when collapsed. uncollapsed: () -&gt; boolean, -- once when uncollapsed. hovered: () -&gt; boolean -- fires when the mouse hovers over any of the window. } States = { size = State&lt;Vector2&gt;?, position = State&lt;Vector2&gt;?, isUncollapsed = State&lt;boolean&gt;?, isOpened = State&lt;boolean&gt;?, scrollDistance = State&lt;number&gt;? -- vertical scroll distance, if too short. }   "},{"title":"Tooltip​","type":1,"pageTitle":"Window","url":"/Iris/api/Window#Tooltip","content":"Widget &lt;/&gt; Window.Tooltip: Iris.Tooltip Displays a text label next to the cursor hasChildren = false hasState = false Arguments = { Text: string }  "},{"title":"Menu","type":0,"sectionRef":"#","url":"/Iris/api/Menu","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#properties","content":" "},{"title":"MenuBar​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#MenuBar","content":"Widget HasChildren &lt;/&gt; Menu.MenuBar: Iris.MenuBar Creates a MenuBar for the current window. Must be called directly under a Window and not within a child widget. info This does not create any menus, just tells the window that we going to add menus within. hasChildren = true hasState = false   "},{"title":"Menu​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#Menu","content":"Widget HasChildren HasState &lt;/&gt; Menu.Menu: Iris.Menu Creates an collapsable menu. If the Menu is created directly under a MenuBar, then the widget will be placed horizontally below the window title. If the menu Menu is created within another menu, then it will be placed vertically alongside MenuItems and display an arrow alongside. The opened menu will be a vertically listed box below or next to the button. info There are widgets which are designed for being parented to a menu whilst other happens to work. There is nothing preventing you from adding any widget as a child, but the behaviour is unexplained and not intended, despite allowed. hasChildren = true hasState = true Arguments = { Text: string -- menu text. } Events = { clicked: () -&gt; boolean, opened: () -&gt; boolean, -- once when opened. closed: () -&gt; boolean, -- once when closed. hovered: () -&gt; boolean } States = { isOpened: State&lt;boolean&gt;? -- whether the menu is open, including any sub-menus within. }   "},{"title":"MenuItem​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#MenuItem","content":"Widget &lt;/&gt; Menu.MenuItem: Iris.MenuItem Creates a button within a menu. The optional KeyCode and ModiferKey arguments will show the keys next to the title, but will not bind any connection to them. You will need to do this yourself. hasChildren = false hasState = false Arguments = { Text: string, KeyCode: Enum.KeyCode? = nil, -- an optional keycode, does not actually connect an event. ModifierKey: Enum.ModifierKey? = nil -- an optional modifer key for the key code. } Events = { clicked: () -&gt; boolean, hovered: () -&gt; boolean }   "},{"title":"MenuToggle​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#MenuToggle","content":"Widget HasState &lt;/&gt; Menu.MenuToggle: Iris.MenuToggle Creates a togglable button within a menu. The optional KeyCode and ModiferKey arguments act the same as the MenuItem. It is not visually the same as a checkbox, but has the same functionality. hasChildren = false hasState = true Arguments = { Text: string, KeyCode: Enum.KeyCode? = nil, -- an optional keycode, does not actually connect an event. ModifierKey: Enum.ModifierKey? = nil -- an optional modifer key for the key code. } Events = { checked: () -&gt; boolean, -- once on check. unchecked: () -&gt; boolean, -- once on uncheck. hovered: () -&gt; boolean } States = { isChecked: State&lt;boolean&gt;? }  "},{"title":"Text","type":0,"sectionRef":"#","url":"/Iris/api/Text","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#properties","content":" "},{"title":"Text​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#Text","content":"Widget &lt;/&gt; Text.Text: Iris.Text A text label to display the text argument. The Wrapped argument will make the text wrap around if it is cut off by its parent. The Color argument will change the color of the text, by default it is defined in the configuration file. The RichText argument will hasChildren = false hasState = false Arguments = { Text: string, Wrapped: boolean? = [CONFIG] = false, -- whether the text will wrap around inside the parent container. If not specified, then equal to the config Color: Color3? = Iris._config.TextColor, -- the colour of the text. RichText: boolean? = [CONFIG] = false -- enable RichText. If not specified, then equal to the config } Events = { hovered: () -&gt; boolean }   "},{"title":"SeparatorText​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#SeparatorText","content":"Widget &lt;/&gt; Text.SeparatorText: Iris.SeparatorText Similar to Iris.Separator but with a text label to be used as a header when an Iris.Tree or Iris.CollapsingHeader is not appropriate. Visually a full width thin line with a text label clipping out part of the line. hasChildren = false hasState = false Arguments = { Text: string }   "},{"title":"InputText​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#InputText","content":"Widget HasState &lt;/&gt; Text.InputText: Iris.InputText A field which allows the user to enter text. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputText&quot;, TextHint: string? = &quot;&quot; -- a hint to display when the text box is empty. } Events = { textChanged: () -&gt; boolean, -- whenever the textbox looses focus and a change was made. hovered: () -&gt; boolean } States = { text: State&lt;string&gt;? }   "},{"title":"TextWrapped​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#TextWrapped","content":"Widget deprecated in v2.0.0 &lt;/&gt; This was deprecated in v2.0.0 Use 'Text' with the Wrapped argument or change the config. Text.TextWrapped: Iris.Text An alias for Iris.Text with the Wrapped argument set to true, and the text will wrap around if cut off by its parent. hasChildren = false hasState = false Arguments = { Text: string, } Events = { hovered: () -&gt; boolean }   "},{"title":"TextColored​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#TextColored","content":"Widget deprecated in v2.0.0 &lt;/&gt; This was deprecated in v2.0.0 Use 'Text' with the Color argument or change the config. Text.TextColored: Iris.Text An alias for Iris.Text with the color set by the Color argument. hasChildren = false hasState = false Arguments = { Text: string, Color: Color3 -- the colour of the text. } Events = { hovered: () -&gt; boolean }  "},{"title":"Combo","type":0,"sectionRef":"#","url":"/Iris/api/Combo","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#properties","content":" "},{"title":"Selectable​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#Selectable","content":"Widget HasState &lt;/&gt; Combo.Selectable: Iris.Selectable An object which can be selected. hasChildren = false hasState = true Arguments = { Text: string, Index: any, -- index of selectable value. NoClick: boolean? = false -- prevents the selectable from being clicked by the user. } Events = { selected: () -&gt; boolean, unselected: () -&gt; boolean, active: () -&gt; boolean, clicked: () -&gt; boolean, rightClicked: () -&gt; boolean, doubleClicked: () -&gt; boolean, ctrlClicked: () -&gt; boolean, hovered: () -&gt; boolean, } States = { index: State&lt;any&gt; -- a shared state between all selectables. }   "},{"title":"Combo​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#Combo","content":"Widget HasChildren HasState &lt;/&gt; Combo.Combo: Iris.Combo A selection box to choose a value from a range of values. hasChildren = true hasState = true Arguments = { Text: string, NoButton: boolean? = false, -- hide the dropdown button. NoPreview: boolean? = false -- hide the preview field. } Events = { opened: () -&gt; boolean, clsoed: () -&gt; boolean, clicked: () -&gt; boolean, hovered: () -&gt; boolean } States = { index: State&lt;any&gt;, isOpened: State&lt;boolean&gt;? }   "},{"title":"ComboArray​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#ComboArray","content":"Widget HasChildren HasState &lt;/&gt; Combo.ComboArray: Iris.Combo A selection box to choose a value from an array. hasChildren = true hasState = true Arguments = { Text: string, NoButton: boolean? = false, -- hide the dropdown button. NoPreview: boolean? = false -- hide the preview field. } Events = { opened: () -&gt; boolean, clsoed: () -&gt; boolean, clicked: () -&gt; boolean, hovered: () -&gt; boolean } States = { index: State&lt;any&gt;, isOpened: State&lt;boolean&gt;? } Extra = { selectionArray: { any } -- the array to generate a combo from. }   "},{"title":"ComboEnum​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#ComboEnum","content":"Widget HasChildren HasState &lt;/&gt; Combo.ComboEnum: Iris.Combo A selection box to choose a value from an Enum. hasChildren = true hasState = true Arguments = { Text: string, NoButton: boolean? = false, -- hide the dropdown button. NoPreview: boolean? = false -- hide the preview field. } Events = { opened: () -&gt; boolean, clsoed: () -&gt; boolean, clicked: () -&gt; boolean, hovered: () -&gt; boolean } States = { index: State&lt;any&gt;, isOpened: State&lt;boolean&gt;? } Extra = { enumType: Enum -- the enum to generate a combo from. }  "},{"title":"Slider","type":0,"sectionRef":"#","url":"/Iris/api/Slider","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#properties","content":" "},{"title":"SliderNum​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderNum","content":"Widget HasState &lt;/&gt; Slider.SliderNum: Iris.SliderNum A field which allows the user to slide a grip to enter a number within a range. You can ctrl + click to directly input a number, like InputNum. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderNum&quot;, Increment: number? = 1, Min: number? = 0, Max: number? = 100, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;number&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderVector2​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderVector2","content":"Widget HasState &lt;/&gt; Slider.SliderVector2: Iris.SliderVector2 A field which allows the user to slide a grip to enter a Vector2 within a range. You can ctrl + click to directly input a Vector2, like InputVector2. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderVector2&quot;, Increment: Vector2? = { 1, 1 }, Min: Vector2? = { 0, 0 }, Max: Vector2? = { 100, 100 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderVector3​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderVector3","content":"Widget HasState &lt;/&gt; Slider.SliderVector3: Iris.SliderVector3 A field which allows the user to slide a grip to enter a Vector3 within a range. You can ctrl + click to directly input a Vector3, like InputVector3. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderVector3&quot;, Increment: Vector3? = { 1, 1, 1 }, Min: Vector3? = { 0, 0, 0 }, Max: Vector3? = { 100, 100, 100 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector3&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderUDim​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderUDim","content":"Widget HasState &lt;/&gt; Slider.SliderUDim: Iris.SliderUDim A field which allows the user to slide a grip to enter a UDim within a range. You can ctrl + click to directly input a UDim, like InputUDim. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderUDim&quot;, Increment: UDim? = { 0.01, 1 }, Min: UDim? = { 0, 0 }, Max: UDim? = { 1, 960 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderUDim2​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderUDim2","content":"Widget HasState &lt;/&gt; Slider.SliderUDim2: Iris.SliderUDim2 A field which allows the user to slide a grip to enter a UDim2 within a range. You can ctrl + click to directly input a UDim2, like InputUDim2. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderUDim2&quot;, Increment: UDim2? = { 0.01, 1, 0.01, 1 }, Min: UDim2? = { 0, 0, 0, 0 }, Max: UDim2? = { 1, 960, 1, 960 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderRect​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderRect","content":"Widget HasState &lt;/&gt; Slider.SliderRect: Iris.SliderRect A field which allows the user to slide a grip to enter a Rect within a range. You can ctrl + click to directly input a Rect, like InputRect. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderRect&quot;, Increment: Rect? = { 1, 1, 1, 1 }, Min: Rect? = { 0, 0, 0, 0 }, Max: Rect? = { 960, 960, 960, 960 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Rect&gt;?, editingText: State&lt;boolean&gt;? }  "},{"title":"Internal","type":0,"sectionRef":"#","url":"/Iris/api/Internal","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#properties","content":" "},{"title":"_cycleCoroutine​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_cycleCoroutine","content":"&lt;/&gt; Internal._cycleCoroutine: thread The thread which handles all connected functions. Each connection is within a pcall statement which prevents Iris from crashing and instead stopping at the error. "},{"title":"Functions​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#functions","content":" "},{"title":"_cycle​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_cycle","content":"&lt;/&gt; Internal._cycle() → () Called every frame to handle all of the widget management. Any previous frame data is ammended and everything updates.  "},{"title":"WidgetConstructor​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#WidgetConstructor","content":"&lt;/&gt; Internal.WidgetConstructor( type: string,-- name used to denote the widget class. widgetClass: Types.WidgetClass-- table of methods for the new widget. ) → () For each widget, a widget class is created which handles all the operations of a widget. This removes the class nature of widgets, and simplifies the available functions which can be applied to any widget. The widgets themselves are dumb tables containing all the data but no methods to handle any of the data apart from events.  "},{"title":"_Insert​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_Insert","content":"&lt;/&gt; Internal._Insert( widgetType:: string,-- name of widget class. arguments: Types.WidgetArguments?,-- arguments of the widget. states: Types.States?-- states of the widget. ) → Types.Widget-- the widget. Every widget is created through _Insert. An ID is generated based on the line of the calling code and is used to find the previous frame widget if it exists. If no widget exists, a new one is created.  "},{"title":"_GenNewWidget​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_GenNewWidget","content":"&lt;/&gt; Internal._GenNewWidget( widgetType: string, arguments: Types.Arguments,-- arguments of the widget. states: Types.States?,-- states of the widget. ID: Types.ID-- id of the new widget. Determined in Internal._Insert ) → Types.Widget-- the newly created widget. All widgets are created as tables with properties. The widget class contains the functions to create the UI instances and update the widget or change state.  "},{"title":"_ContinueWidget​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_ContinueWidget","content":"&lt;/&gt; Internal._ContinueWidget( ID: Types.ID,-- id of the widget. widgetType: string ) → Types.Widget-- the widget. Since the widget has already been created this frame, we can just add it back to the stack. There is no checking of arguments or states. Basically equivalent to the end of Internal._Insert.  "},{"title":"_DiscardWidget​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_DiscardWidget","content":"&lt;/&gt; Internal._DiscardWidget(widgetToDiscard: Types.Widget) → () Destroys the widget instance and updates any parent. This happens if the widget was not called in the previous frame. There is no code which needs to update any widget tables since they are already reset at the start before discarding happens.  "},{"title":"_widgetState​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_widgetState","content":"&lt;/&gt; Internal._widgetState( thisWidget: Types.Widget,-- widget the state belongs to. stateName: string, initialValue: any ) → Types.State-- the state for the widget. Connects the state to the widget. If no state exists then a new one is created. Called for every state in every widget if the user does not provide a state.  "},{"title":"_EventCall​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_EventCall","content":"&lt;/&gt; Internal._EventCall( thisWidget: Types.Widget, evetName: string ) → boolean-- the value of the event. A wrapper for any event on any widget. Automatically, Iris does not initialize events unless they are explicitly called so in the first frame, the event connections are set up. Every event is a function which returns a boolean.  "},{"title":"_GetParentWidget​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_GetParentWidget","content":"&lt;/&gt; Internal._GetParentWidget() → Types.Widget-- the parent widget Returns the parent widget of the currently active widget, based on the stack depth.  "},{"title":"_getID​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_getID","content":"&lt;/&gt; Internal._getID( levelsToIgnore: number-- used to skip over internal calls to _getID. ) → () Generates a unique ID for each widget which is based on the line that the widget is created from. This ensures that the function is heuristic and always returns the same id for the same widget. "},{"title":"Input","type":0,"sectionRef":"#","url":"/Iris/api/Input","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#properties","content":" "},{"title":"InputNum​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputNum","content":"Widget HasState &lt;/&gt; Input.InputNum: Iris.InputNum An input box for numbers. The number can be either an integer or a float. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputNum&quot;, Increment: number? = nil, Min: number? = nil, Max: number? = nil, Format: string? | { string }? = [DYNAMIC], -- Iris will dynamically generate an approriate format. NoButtons: boolean? = false -- whether to display + and - buttons next to the input box. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;number&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputVector2​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputVector2","content":"Widget HasState &lt;/&gt; Input.InputVector2: Iris.InputVector2 An input box for Vector2. The numbers can be either integers or floats. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputVector2&quot;, Increment: Vector2? = nil, Min: Vector2? = nil, Max: Vector2? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputVector3​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputVector3","content":"Widget HasState &lt;/&gt; Input.InputVector3: Iris.InputVector3 An input box for Vector3. The numbers can be either integers or floats. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputVector3&quot;, Increment: Vector3? = nil, Min: Vector3? = nil, Max: Vector3? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector3&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputUDim​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputUDim","content":"Widget HasState &lt;/&gt; Input.InputUDim: Iris.InputUDim An input box for UDim. The Scale box will be a float and the Offset box will be an integer, unless specified differently. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputUDim&quot;, Increment: UDim? = nil, Min: UDim? = nil, Max: UDim? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputUDim2​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputUDim2","content":"Widget HasState &lt;/&gt; Input.InputUDim2: Iris.InputUDim2 An input box for UDim2. The Scale boxes will be floats and the Offset boxes will be integers, unless specified differently. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputUDim2&quot;, Increment: UDim2? = nil, Min: UDim2? = nil, Max: UDim2? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputRect​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputRect","content":"Widget HasState &lt;/&gt; Input.InputRect: Iris.InputRect An input box for Rect. The numbers will default to integers, unless specified differently. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputRect&quot;, Increment: Rect? = nil, Min: Rect? = nil, Max: Rect? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Rect&gt;?, editingText: State&lt;boolean&gt;? }  "},{"title":"Drag","type":0,"sectionRef":"#","url":"/Iris/api/Drag","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#properties","content":" "},{"title":"DragNum​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragNum","content":"Widget HasState &lt;/&gt; Drag.DragNum: Iris.DragNum A field which allows the user to click and drag their cursor to enter a number. You can ctrl + click to directly input a number, like InputNum. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragNum&quot;, Increment: number? = nil, Min: number? = nil, Max: number? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;number&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragVector2​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragVector2","content":"Widget HasState &lt;/&gt; Drag.DragVector2: Iris.DragVector2 A field which allows the user to click and drag their cursor to enter a Vector2. You can ctrl + click to directly input a Vector2, like InputVector2. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragVector2&quot;, Increment: Vector2? = nil, Min: Vector2? = nil, Max: Vector2? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragVector3​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragVector3","content":"Widget HasState &lt;/&gt; Drag.DragVector3: Iris.DragVector3 A field which allows the user to click and drag their cursor to enter a Vector3. You can ctrl + click to directly input a Vector3, like InputVector3. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragVector3&quot;, Increment: Vector3? = nil, Min: Vector3? = nil, Max: Vector3? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector3&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragUDim​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragUDim","content":"Widget HasState &lt;/&gt; Drag.DragUDim: Iris.DragUDim A field which allows the user to click and drag their cursor to enter a UDim. You can ctrl + click to directly input a UDim, like InputUDim. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragUDim&quot;, Increment: UDim? = nil, Min: UDim? = nil, Max: UDim? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragUDim2​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragUDim2","content":"Widget HasState &lt;/&gt; Drag.DragUDim2: Iris.DragUDim2 A field which allows the user to click and drag their cursor to enter a UDim2. You can ctrl + click to directly input a UDim2, like InputUDim2. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragUDim2&quot;, Increment: UDim2? = nil, Min: UDim2? = nil, Max: UDim2? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragRect​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragRect","content":"Widget HasState &lt;/&gt; Drag.DragRect: Iris.DragRect A field which allows the user to click and drag their cursor to enter a Rect. You can ctrl + click to directly input a Rect, like InputRect. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragRect&quot;, Increment: Rect? = nil, Min: Rect? = nil, Max: Rect? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Rect&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputColor3​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#InputColor3","content":"Widget HasState &lt;/&gt; Drag.InputColor3: Iris.InputColor3 An input box for Color3. The input boxes are draggable between 0 and 255 or if UseFloats then between 0 and 1. Input can also be done using HSV instead of the default RGB. If no format argument is provided then a default R, G, B or H, S, V prefix is applied. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputColor3&quot;, UseFloats: boolean? = false, -- constrain the values between floats 0 and 1 or integers 0 and 255. UseHSV: boolean? = false, -- input using HSV instead. Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { color: State&lt;Color3&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputColor4​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#InputColor4","content":"Widget HasState &lt;/&gt; Drag.InputColor4: Iris.InputColor4 An input box for Color4. Color4 is a combination of Color3 and a fourth transparency argument. It has two states for this purpose. The input boxes are draggable between 0 and 255 or if UseFloats then between 0 and 1. Input can also be done using HSV instead of the default RGB. If no format argument is provided then a default R, G, B, T or H, S, V, T prefix is applied. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputColor4&quot;, UseFloats: boolean? = false, -- constrain the values between floats 0 and 1 or integers 0 and 255. UseHSV: boolean? = false, -- input using HSV instead. Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { color: State&lt;Color3&gt;?, transparency: State&lt;number&gt;?, editingText: State&lt;boolean&gt;? }  "},{"title":"Creating Custom Widgets","type":0,"sectionRef":"#","url":"/Iris/docs/creatingCustomWidgets","content":"","keywords":""},{"title":"Generate​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#generate","content":"Generate is called when a widget is first instantiated. It should create all the instances and properly adjust them to fit the config properties. Generate is also called when style properties change. Generate should return the instance which acts as the root of the widget. (what should be parented to the parents designated Instance) "},{"title":"Update​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#update","content":"Update is called only after instantiation and when widget arguments have changed. For instance, in Iris.Text Update = function(thisWidget) local Text = thisWidget.Instance if thisWidget.arguments.Text == nil then error(&quot;Iris.Text Text Argument is required&quot;, 5) end Text.Text = thisWidget.arguments.Text end  "},{"title":"Discard​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#discard","content":"Discard is called when the widget stops being displayed. In most cases the function body should resemble this: Discard = function(thisWidget) thisWidget.Instance:Destroy() end  "},{"title":"Events​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#events","content":"Events is a table, not a method. It contains all of the possible events which a widget can have. Lets look at the hovered event as an example. [&quot;hovered&quot;] = { [&quot;Init&quot;] = function(thisWidget) local hoveredGuiObject = thisWidget.Instance thisWidget.isHoveredEvent = false hoveredGuiObject.MouseEnter:Connect(function() thisWidget.isHoveredEvent = true end) hoveredGuiObject.MouseLeave:Connect(function() thisWidget.isHoveredEvent = false end) end, [&quot;Get&quot;] = function(thisWidget) return thisWidget.isHoveredEvent end }  Every event has 2 methods, Init and Get.Init is called when a widget first polls the value of an event. Because of this, you can instantiate events and variables for an event to only widgets which need it.Get is the actual function which is called by the call to an event (like Button.hovered()), it should return the event value. "},{"title":"Args​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#args","content":"Args is a table, not a method. It enumerates all of the possible arguments which may be passed as arguments into the widget. The order of the tables indicies indicate which position the Argument will be interpreted as. For instance, in Iris.Text: Args = { [&quot;Text&quot;] = 1 }  when a Text widget is generated, the first index of the Arguments table will be interpreted as the 'Text' parameter Iris.Text({[1] = &quot;Hello&quot;}) -- same result Iris.Text({&quot;Hello&quot;})  the Update function can retrieve arguments from thisWidget.arguments, such as thisWidget.arguments.Text "},{"title":"GenerateState​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#generatestate","content":"GenerateState is called when the widget is first Instantiated, It should generate any state objects which weren't passed as a state by the user. For Instance, in Iris.Checkbox: GenerateState = function(thisWidget) if thisWidget.state.isChecked == nil then thisWidget.state.isChecked = Iris._widgetState(thisWidget, &quot;checked&quot;, false) end end  "},{"title":"UpdateState​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#updatestate","content":"UpdateState is called whenever ANY state objects are updated, using its :set() method. For instance, in Iris.Checkbox: UpdateState = function(thisWidget) local Checkbox = thisWidget.Instance.CheckboxBox if thisWidget.state.isChecked.value then Checkbox.Text = ICONS.CHECK_MARK thisWidget.events.checked = true else Checkbox.Text = &quot;&quot; thisWidget.events.unchecked = true end end  caution calling :set() to any of a widget's own state objects inside of UpdateState may cause an infinite loop of state updates. UpdateState should avoid calling :set(). "},{"title":"ChildAdded​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#childadded","content":"ChildAdded is called when a widget is first Initiated and is a child of the widget. ChildAdded should return the Instance which the Child will be parented to. "},{"title":"ChildDiscarded​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#childdiscarded","content":"ChildDiscarded is called when a widget is Discarded and is a child of the widget. ChildDiscarded is optional.  "},{"title":"When does a widget need to have state?​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#when-does-a-widget-need-to-have-state","content":"State should only be used by widgets when there are properties which are able to be set by BOTH the widget, and by the user's code. For Instance, Iris.Window has a state, size. This field can be changed by the user's code, to adjust or initiate the size, and the widget also changes the size when it is resized. If the window was never able to change the size property, such as if there were no resize feature, then instead it should be an argument. This table demonstrates the relation between User / Widget permissions, and where the field should belong inside the widget class.  "},{"title":"Iris","type":0,"sectionRef":"#","url":"/Iris/api/Iris","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#properties","content":" "},{"title":"Disabled​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Disabled","content":"&lt;/&gt; Iris.Disabled: boolean While Iris.Disabled is true, execution of Iris and connected functions will be paused. The widgets are not destroyed, they are just frozen so no changes will happen to them.  "},{"title":"Args​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Args","content":"&lt;/&gt; Iris.Args: table Provides a list of every possible Argument for each type of widget to it's index. For instance, Iris.Args.Window.NoResize. The Args table is useful for using widget Arguments without remembering their order. Iris.Window({&quot;My Window&quot;, [Iris.Args.Window.NoResize] = true})   "},{"title":"TemplateConfig​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#TemplateConfig","content":"&lt;/&gt; Iris.TemplateConfig: table TemplateConfig provides a table of default styles and configurations which you may apply to your UI. "},{"title":"Functions​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#functions","content":" "},{"title":"SetFocusedWindow​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#SetFocusedWindow","content":"&lt;/&gt; Iris.SetFocusedWindow( window: Types.Widget-- the window to focus. ) → () Sets the focused window to the window provided, which brings it to the front and makes it active.  "},{"title":"Init​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Init","content":"&lt;/&gt; Iris.Init( parentInstance: Instance | nil,-- instance which Iris will place UI in. defaults to PlayerGui if unspecified eventConnection: RBXScriptSignal | () → {} | nil ) → Iris Initializes Iris and begins rendering. May only be called once. By default, Iris will create its widgets under the PlayerGui and use the Heartbeat event.  "},{"title":"Append​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Append","content":"&lt;/&gt; Iris.Append() → () Allows the caller to insert any Roblox Instance into Iris. The parent can either be determined by the _config.Parent property or by the current parent widget from the stack.  "},{"title":"End​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#End","content":"&lt;/&gt; Iris.End() → () This function marks the end of any widgets which contain children. For example: -- Widgets placed here **will not** be inside the tree Iris.Tree({&quot;My First Tree&quot;}) -- Widgets placed here **will** be inside the tree Iris.End() -- Widgets placed here **will not** be inside the tree Caution: Error Seeing the error Callback has too few calls to Iris.End() or Callback has too many calls to Iris.End()? Using the wrong amount of Iris.End() calls in your code will lead to an error. Each widget called which might have children should be paired with a call to Iris.End(), Even if the Widget doesnt currently have any children.  "},{"title":"ForceRefresh​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#ForceRefresh","content":"&lt;/&gt; Iris.ForceRefresh() → () Destroys and regenerates all instances used by Iris. Useful if you want to propogate state changes. Caution: Performance Because this function Deletes and Initializes many instances, it may cause performance issues when used with many widgets. In no case should it be called every frame.  "},{"title":"UpdateGlobalConfig​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#UpdateGlobalConfig","content":"&lt;/&gt; Iris.UpdateGlobalConfig( deltaStyle: table-- a table containing the changes in style ex: {ItemWidth = UDim.new(0, 100)} ) → () Allows callers to customize the config which every widget will inherit from. It can be used along with Iris.TemplateConfig to easily swap styles, ex: Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight) -- use light theme Caution: Performance this function internally calls Iris.ForceRefresh so that style changes are propogated, it may cause performance issues when used with many widgets. In no case should it be called every frame.  "},{"title":"PushConfig​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#PushConfig","content":"&lt;/&gt; Iris.PushConfig( deltaStyle: table-- a table containing the changes in style ex: {ItemWidth = UDim.new(0, 100)} ) → () Allows callers to cascade a style, meaning that styles may be locally and hierarchically applied. Each call to Iris.PushConfig must be paired with a call to Iris.PopConfig. For example: Iris.PushConfig({TextColor = Color3.fromRGB(128, 0, 256)}) Iris.Text({&quot;Colored Text!&quot;}) Iris.PopConfig()   "},{"title":"PopConfig​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#PopConfig","content":"&lt;/&gt; Iris.PopConfig() → () Ends a PushConfig style. Each call to Iris.PushConfig must be paired with a call to Iris.PopConfig.  "},{"title":"PushId​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#PushId","content":"&lt;/&gt; Iris.PushId( id: Types.ID-- custom id. ) → () Sets the id discriminator for the next widgets. Use Iris.PopId to remove it.  "},{"title":"PopId​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#PopId","content":"&lt;/&gt; Iris.PopId() → () Removes the id discriminator set by Iris.PushId.  "},{"title":"SetNextWidgetId​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#SetNextWidgetId","content":"&lt;/&gt; Iris.SetNextWidgetId( id: Types.ID-- custom id. ) → () Sets the id for the next widget. Useful for using Iris.Append on the same widget. Iris.SetNextWidgetId(&quot;demo_window&quot;) Iris.Window({ &quot;Window&quot; }) Iris.Text({ &quot;Text one placed here.&quot; }) Iris.End() -- later in the code Iris.SetNextWidgetId(&quot;demo_window&quot;) Iris.Window() Iris.Text({ &quot;Text two placed here.&quot; }) Iris.End() -- both text widgets will be placed under the same window despite being called separately.   "},{"title":"State​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#State","content":"&lt;/&gt; Iris.State( initialValue: any-- The initial value for the state ) → () Constructs a new state object, subsequent ID calls will return the same object info Iris.State allows you to create &quot;references&quot; to the same value while inside your UI drawing loop. For example: Iris:Connect(function() local myNumber = 5; myNumber = myNumber + 1 Iris.Text({&quot;The number is: &quot; .. myNumber}) end) This is problematic. Each time the function is called, a new myNumber is initialized, instead of retrieving the old one. The above code will always display 6. Iris.State solves this problem: Iris:Connect(function() local myNumber = Iris.State(5) myNumber:set(myNumber:get() + 1) Iris.Text({&quot;The number is: &quot; .. myNumber}) end) In this example, the code will work properly, and increment every frame.  "},{"title":"WeakState​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#WeakState","content":"&lt;/&gt; Iris.WeakState( initialValue: any-- The initial value for the state ) → () Constructs a new state object, subsequent ID calls will return the same object, except all widgets connected to the state are discarded, the state reverts to the passed initialValue  "},{"title":"ComputedState​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#ComputedState","content":"&lt;/&gt; Iris.ComputedState( firstState: State,-- State to bind to. onChangeCallback: function-- callback which should return a value transformed from the firstState value ) → () Constructs a new State object, but binds its value to the value of another State. info A common use case for this constructor is when a boolean State needs to be inverted: Iris.ComputedState(otherState, function(newValue) return not newValue end)   "},{"title":"ShowDemoWindow​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#ShowDemoWindow","content":"&lt;/&gt; Iris.ShowDemoWindow() → () ShowDemoWindow is a function which creates a Demonstration window. this window contains many useful utilities for coders, and serves as a refrence for using each part of the library. Ideally, the DemoWindow should always be available in your UI. It is the same as any other callback you would connect to Iris using Iris.Connect Iris:Connect(Iris.ShowDemoWindow)   "},{"title":"Shutdown​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Shutdown","content":"&lt;/&gt; Iris:Shutdown() → ()   "},{"title":"Connect​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Connect","content":"&lt;/&gt; Iris:Connect( callback: function-- the callback containg the Iris code. ) → () Allows users to connect a function which will execute every Iris cycle, (cycle is determined by the callback or event passed to Iris.Init or default to Heartbeat). Multiple callbacks can be added to Iris from many different scripts or modules. "}]