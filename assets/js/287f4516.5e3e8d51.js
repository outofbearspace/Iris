"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7647],{46699:e=>{e.exports=JSON.parse('{"functions":[{"name":"_cycle","desc":"Called every frame to handle all of the widget management. Any previous frame data is ammended and everything updates.\\n    ","params":[],"returns":[],"function_type":"static","source":{"line":177,"path":"lib/Internal.lua"}},{"name":"_NoOp","desc":"A dummy function which does nothing. Used as a placeholder for optional methods in a widget class.\\nUsed in `Internal.WidgetConstructor`\\n    ","params":[],"returns":[],"function_type":"static","ignore":true,"source":{"line":280,"path":"lib/Internal.lua"}},{"name":"WidgetConstructor","desc":"For each widget, a widget class is created which handles all the operations of a widget. This removes the class nature\\nof widgets, and simplifies the available functions which can be applied to any widget. The widgets themselves are\\ndumb tables containing all the data but no methods to handle any of the data apart from events.\\n    ","params":[{"name":"type","desc":"name used to denote the widget class.","lua_type":"string"},{"name":"widgetClass","desc":"table of methods for the new widget.","lua_type":"Types.WidgetClass"}],"returns":[],"function_type":"static","source":{"line":294,"path":"lib/Internal.lua"}},{"name":"_Insert","desc":"Every widget is created through _Insert. An ID is generated based on the line of the calling code and is used to\\nfind the previous frame widget if it exists. If no widget exists, a new one is created.\\n    ","params":[{"name":"widgetType:","desc":"name of widget class.","lua_type":"string"},{"name":"arguments","desc":"arguments of the widget.","lua_type":"Types.WidgetArguments?"},{"name":"states","desc":"states of the widget.","lua_type":"Types.States?"}],"returns":[{"desc":"the widget.","lua_type":"Types.Widget"}],"function_type":"static","source":{"line":403,"path":"lib/Internal.lua"}},{"name":"_GenNewWidget","desc":"All widgets are created as tables with properties. The widget class contains the functions to create the UI instances and\\nupdate the widget or change state.\\n    ","params":[{"name":"widgetType","desc":"","lua_type":"string"},{"name":"arguments","desc":"arguments of the widget.","lua_type":"Types.Arguments"},{"name":"states","desc":"states of the widget.","lua_type":"Types.States?"},{"name":"ID","desc":"id of the new widget. Determined in `Internal._Insert`","lua_type":"Types.ID"}],"returns":[{"desc":"the newly created widget.","lua_type":"Types.Widget"}],"function_type":"static","source":{"line":483,"path":"lib/Internal.lua"}},{"name":"_ContinueWidget","desc":"Since the widget has already been created this frame, we can just add it back to the stack. There is no checking of\\narguments or states.\\nBasically equivalent to the end of `Internal._Insert`.\\n    ","params":[{"name":"ID","desc":"id of the widget.","lua_type":"Types.ID"},{"name":"widgetType","desc":"","lua_type":"string"}],"returns":[{"desc":"the widget.","lua_type":"Types.Widget"}],"function_type":"static","source":{"line":557,"path":"lib/Internal.lua"}},{"name":"_DiscardWidget","desc":"Destroys the widget instance and updates any parent. This happens if the widget was not called in the\\nprevious frame. There is no code which needs to update any widget tables since they are already reset\\nat the start before discarding happens.\\n    ","params":[{"name":"widgetToDiscard","desc":"","lua_type":"Types.Widget"}],"returns":[],"function_type":"static","source":{"line":580,"path":"lib/Internal.lua"}},{"name":"_widgetState","desc":"Connects the state to the widget. If no state exists then a new one is created. Called for every state in every\\nwidget if the user does not provide a state.\\n    ","params":[{"name":"thisWidget","desc":"widget the state belongs to.","lua_type":"Types.Widget"},{"name":"stateName","desc":"","lua_type":"string"},{"name":"initialValue","desc":"","lua_type":"any"}],"returns":[{"desc":"the state for the widget.","lua_type":"Types.State"}],"function_type":"static","source":{"line":602,"path":"lib/Internal.lua"}},{"name":"_EventCall","desc":"A wrapper for any event on any widget. Automatically, Iris does not initialize events unless they are explicitly\\ncalled so in the first frame, the event connections are set up. Every event is a function which returns a boolean.\\n    ","params":[{"name":"thisWidget","desc":"","lua_type":"Types.Widget"},{"name":"evetName","desc":"","lua_type":"string"}],"returns":[{"desc":"the value of the event.","lua_type":"boolean"}],"function_type":"static","source":{"line":628,"path":"lib/Internal.lua"}},{"name":"_GetParentWidget","desc":"Returns the parent widget of the currently active widget, based on the stack depth.\\n    ","params":[],"returns":[{"desc":"the parent widget","lua_type":"Types.Widget"}],"function_type":"static","source":{"line":647,"path":"lib/Internal.lua"}},{"name":"_generateEmptyVDOM","desc":"Creates the VDOM at the start of each frame containing jsut the root instance.\\n    ","params":[],"returns":[],"function_type":"static","ignore":true,"source":{"line":660,"path":"lib/Internal.lua"}},{"name":"_generateRootInstance","desc":"Creates the root instance.\\n    ","params":[],"returns":[],"function_type":"static","ignore":true,"source":{"line":673,"path":"lib/Internal.lua"}},{"name":"_generateSelctionImageObject","desc":"Creates the selection object for buttons.\\n    ","params":[],"returns":[],"function_type":"static","ignore":true,"source":{"line":687,"path":"lib/Internal.lua"}},{"name":"_getID","desc":"Generates a unique ID for each widget which is based on the line that the widget is\\ncreated from. This ensures that the function is heuristic and always returns the same\\nid for the same widget.\\n    ","params":[{"name":"levelsToIgnore","desc":"used to skip over internal calls to `_getID`.","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":727,"path":"lib/Internal.lua"}},{"name":"_deepCompare","desc":"Compares two tables to check if they are the same. It uses a recursive iteration through one table\\nto compare against the other. Used to determine if the arguments of a widget have changed since last\\nframe.\\n    ","params":[{"name":"t1","desc":"","lua_type":"table"},{"name":"t2","desc":"","lua_type":"table"}],"returns":[],"function_type":"static","ignore":true,"source":{"line":765,"path":"lib/Internal.lua"}},{"name":"_deepCopy","desc":"Performs a deep copy of a table so that neither table contains a shared reference.\\n    ","params":[{"name":"t","desc":"","lua_type":"table"}],"returns":[],"function_type":"static","ignore":true,"source":{"line":795,"path":"lib/Internal.lua"}}],"properties":[{"name":"_cycleCoroutine","desc":"The thread which handles all connected functions. Each connection is within a pcall statement which prevents\\nIris from crashing and instead stopping at the error.\\n    ","lua_type":"thread","source":{"line":69,"path":"lib/Internal.lua"}}],"types":[],"name":"Internal","desc":"An internal class within Iris containing all the backend data and functions for Iris to operate.\\nIt is recommended that you don\'t generally interact with Internal unless you understand what you are doing.\\n    ","source":{"line":9,"path":"lib/Internal.lua"}}')}}]);